// schema-builder.js
class SchemaBuilder {
   constructor(tableName, dialect = "postgresql") {
      this.tableName = tableName;
      this.columns = [];
      this.dialect = dialect.toLowerCase();
   }

   increments(columnName) {
      let type;
      switch (this.dialect) {
         case "postgresql":
            type = "SERIAL PRIMARY KEY";
            break;
         case "mysql":
         case "mariadb":
            type = "INT AUTO_INCREMENT PRIMARY KEY";
            break;
         case "sqlite":
            type = "INTEGER PRIMARY KEY AUTOINCREMENT";
            break;
         case "sqlserver":
            type = "INT IDENTITY(1,1) PRIMARY KEY";
            break;
         case "oracle":
            type = "NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY";
            break;
         case "db2":
            type = "INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY";
            break;
         default:
            throw new Error(`Unsupported dialect: ${this.dialect}`);
      }
      this.columns.push({ name: columnName, type });
      return this;
   }

   string(columnName, length = 255) {
      this.columns.push({ name: columnName, type: `VARCHAR(${length})` });
      return this;
   }

   integer(columnName) {
      this.columns.push({ name: columnName, type: "INTEGER" });
      return this;
   }

   boolean(columnName) {
      this.columns.push({ name: columnName, type: "BOOLEAN" });
      return this;
   }

   text(columnName) {
      this.columns.push({ name: columnName, type: "TEXT" });
      return this;
   }

   date(columnName) {
      this.columns.push({ name: columnName, type: "DATE" });
      return this;
   }

   timestamps() {
      let timestampType = this.dialect === "sqlite" ? "DATETIME" : "TIMESTAMP";
      this.columns.push({ name: "created_at", type: `${timestampType} DEFAULT CURRENT_TIMESTAMP` });
      if (this.dialect !== "sqlserver" && this.dialect !== "oracle") {
         this.columns.push({ name: "updated_at", type: `${timestampType} DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` });
      }
      return this;
   }

   enum(columnName, values) {
      let type;
      if (this.dialect === "postgresql" || this.dialect === "mysql" || this.dialect === "mariadb") {
         type = `ENUM(${values.map(v => `'${v}'`).join(", ")})`;
      } else {
         type = `TEXT CHECK (${columnName} IN (${values.map(v => `'${v}'`).join(",")}))`;
      }
      this.columns.push({ name: columnName, type });
      return this;
   }

   json(columnName) {
      let type = this.dialect === "postgresql" || this.dialect === "mysql" ? "JSON" : "TEXT";
      this.columns.push({ name: columnName, type });
      return this;
   }

   decimal(columnName, precision = 10, scale = 2) {
      this.columns.push({ name: columnName, type: `DECIMAL(${precision}, ${scale})` });
      return this;
   }

   bigInteger(columnName) {
      this.columns.push({ name: columnName, type: "BIGINT" });
      return this;
   }

   defaultTo(columnName, value) {
      const column = this.columns.find(col => col.name === columnName);
      if (column) {
         column.default = value;
      }
      return this;
   }

   primary(columnName) {
      this.columns.push({ constraint: "PRIMARY KEY", columns: [columnName] });
      return this;
   }

   unique(columnName) {
      this.columns.push({ constraint: "UNIQUE", columns: [columnName] });
      return this;
   }

   foreign(columnName, referencesTable, referencesColumn) {
      this.columns.push({ constraint: "FOREIGN KEY", columns: [columnName], references: { table: referencesTable, column: referencesColumn } });
      return this;
   }

   toSQL() {
      const columnDefinitions = this.columns.map(col => {
         if (col.constraint) {
            return `${col.constraint} (${col.columns.join(", ")})`;
         }
         let definition = `${col.name} ${col.type}`;
         if (col.default !== undefined) {
            definition += ` DEFAULT ${col.default}`;
         }
         return definition;
      });

      return `CREATE TABLE ${this.tableName} (
  ${columnDefinitions.join(",\n  ")}
);`;
   }

   toJSON() {
      return {
         tableName: this.tableName,
         columns: this.columns,
         dialect: this.dialect,
      };
   }
}

// Helper function to create schema
function createSchema(tableName, callback, dialect = "postgresql") {
   const builder = new SchemaBuilder(tableName, dialect);
   callback(builder);
   return {
      sql: builder.toSQL(),
      json: builder.toJSON(),
   };
}

// Example Usage
const schema = createSchema("users", (table) => {
   table.increments("id");
   table.string("name");
   table.boolean("is_active").defaultTo(true);
   table.enum("role", ["admin", "user", "guest"]);
   table.json("metadata");
   table.decimal("balance", 12, 4);
   table.bigInteger("views");
   table.timestamps();
}, "mysql");

console.log("SQL:", schema.sql);
console.log("JSON:", JSON.stringify(schema.json, null, 2));

module.exports = { createSchema, SchemaBuilder };